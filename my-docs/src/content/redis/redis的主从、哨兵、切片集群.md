# redis的主从、哨兵、切片集群

随着业务量的增长，单一的Redis实例已经无法满足我们的需求。本文将深入探讨Redis的三种高可用性实践：主从复制、哨兵机制以及切片集群，构建更加健壮的Redis服务。

### 主从复制：数据同步的基石

主从复制是Redis高可用性配置的基础。在这种模式下，一个Redis服务器充当主服务器，而一个或多个服务器作为从服务器。从服务器会复制主服务器的数据，以此来实现数据的冗余备份。同时主从库之间采用的是读写分离的方式：读操作主库、从库都可以接收；写操作首先到主库执行，然后在从主库同步给从库。

#### 全量同步

那么主从库之间如何进行数据同步呢？当刚启动多个redis实例，在从节点执行replicaof命令关联主节点时，两者就已建立连接，并准备全量复制。

```
replicaof  xxx.xx.xx.xx  6379
```

具体来说，主库执行 bgsave 命令，fork出子线程来生成全量数据的 RDB 文件发给从库。从库接收到 RDB 文件后，为保证数据一致性会先清空当前数据库，然后加载 RDB 文件。

在这一同步的过程中，主库不会被阻塞，仍然可以正常接收请求，也会在内存中用专门的replication buffer（写缓冲区），记录 RDB 文件生成后收到的所有写操作。最后主库再将replication buffer中的数据发给从库，从而完成全量同步。

从服务器在与主服务器建立连接后，会维持一个持久的网络连接，以便持续地进行数据同步，这个过程也称为基于长连接的命令传播。这个长连接主要用于增量同步，确保从服务器能够实时地接收到主服务器上的数据变更。

#### 增量同步

在Redis的主从复制中，replication buffer和repl\_backlog\_buffer都扮演着重要的角色，但它们的用途和工作方式有所不同。

replication buffer是主服务器上的一个缓冲区，用于存储将要发送给所有从服务器的写命令。当主服务器执行写操作时，这些命令会被放入replication buffer中，然后异步地发送给所有连接的从服务器。这个缓冲区确保了所有从服务器都能够接收到主服务器上发生的变更。

然而，网络问题或其他故障可能导致从服务器与主服务器之间的连接断开。在这种情况下，如果从服务器重新连接并尝试同步，而replication buffer中的数据已经被覆盖（因为replication buffer是一个有限大小的缓冲区，旧的命令会被新的命令覆盖），从服务器就无法获取到断开期间主服务器上发生的变更。

这时候repl\_backlog\_buffer，主服务器上的另一个缓冲区，就派上了用场。它以循环的方式存储一定时间内的写命令。即使replication buffer中的数据已经被新数据覆盖，repl\_backlog\_buffer仍然保留着这些旧数据。这样，即使从服务器在断开连接一段时间后重新连接，它仍然可以从repl\_backlog\_buffer中获取到断开期间错过的命令，并更新自己的数据。

![img](https://javacool.oss-cn-shenzhen.aliyuncs.com/img/xyr/20240525180019.png)

### 哨兵机制：自动故障检测与恢复

哨兵机制是Redis提供的一种自动故障检测和恢复机制，一个哨兵其实也是一个redis进程。通过部署多个哨兵节点，它们会定期检查服务器的状态。一旦主服务器出现故障，哨兵会自动将某个从服务器升级为新的主服务器，以此来保证Redis服务的高可用性。

1.  故障检测


哨兵节点会周期性地给所有的主从库发送 PING 命令，即发送心跳包给主从服务器，检测它们是否仍然在线运行。如果在一定时间内没有收到响应，哨兵会认为服务器已经下线，并开始故障转移的流程。

2.  主从切换


当主服务器被判定为不可用时，哨兵之间会进行一次投票，选择一个新的主服务器。这个过程是自动的，不需要人工干预，大大提高了系统的恢复速度。需要注意的是，执行主从切换是由哨兵leader来操作的，而leader的产生也是需要进行选举投票的。

3.  消息通知


选举出新的主库之后，哨兵会把新主库的连接信息发给其他从库，让它们执行 replicaof 命令，和新主库建立连接，并进行数据复制。同时，哨兵会把新主库的连接信息通知给客户端，让它们把请求操作发到新主库上。

### 切片集群：水平扩展的解决方案

随着数据量的不断增长，单个Redis实例的性能瓶颈也日益凸显。切片集群（Cluster）是Redis提供的一种分布式解决方案，它将数据分散存储在多个节点上，以此来实现水平扩展。

在Redis集群中，所有的数据被分成16384个哈希槽。每个节点负责一部分哈希槽，当客户端发起请求时，根据键值计算出对应的哈希槽，然后路由到对应的节点上。这样，数据就被均匀地分布在集群中的各个节点上。当然，也可以手动分配哈希槽，但需要把 16384 个槽都分配完，否则 Redis 集群无法正常工作。

Redis 实例会把自己的哈希槽信息发给和它相连接的其它实例，来完成哈希槽分配信息的扩散。当实例之间相互连接后，每个实例就有了所有哈希槽的映射关系。

同时，集群中的每个节点都会维护一张集群状态图。每个节点都会定期通过Gossip协议与其他节点通信，交换状态信息，以此来监控集群中其他节点的健康状态。如果在一定时间内，集群中的多数节点都收到了关于某个节点不可达的信息，那么这个节点会被标记为“客观下线”（客观故障）。一旦节点被标记为客观下线，集群会尝试进行故障恢复，例如通过将故障节点负责的数据槽（slot）迁移到其他健康的节点上。

在cluster集群中，合并操作是不被允许的，如mget命令，具体原因其实官网已经给了说明。地址：https://redis.io/docs/latest/operate/oss_and_stack/reference/cluster-spec/

Redis 中的值通常非常大，包含数百万个元素的列表或排序集是很常见的。数据类型在语义上也很复杂。传输和合并这些类型的值可能是主要瓶颈，比较消耗性能。尽管MGET命令在Redis Cluster中不被支持，但用户可以通过其他方式来实现类似的功能。例如，可以使用Lua脚本在单个节点上执行多个GET操作，或者通过客户端逻辑将请求分发到正确的节点上。

![img_1](https://javacool.oss-cn-shenzhen.aliyuncs.com/img/xyr/20240525180236.png)

### 结语

在选择Redis的主从复制、哨兵机制和切片集群时，需要根据具体的业务场景和需求来决定。对于小型到中型应用，主从复制可能是一个简单有效的选择。当对高可用性有严格要求时，哨兵机制提供了自动故障转移的能力。而对于需要处理大规模数据和高并发请求的应用，切片集群通过分片技术实现了水平扩展和负载均衡。每种方案都有其适用场景和优缺点，需要根据实际情况进行权衡选择。

