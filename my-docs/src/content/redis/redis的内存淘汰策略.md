# Redis的key过期如何删除？有哪些内存淘汰策略？

随着业务的发展，数据量激增，Redis作为缓存数据库，其内存使用量不可避免地会增长。但内存终究是有限的，一台服务器的内存也就8G或者16G，redis也不可能全部占用，因为一部分内存也需要用来维持系统运行。那redis又该怎么处理内存占用过多的情况呢？

### key设置过期时间

在设计缓存策略时，给键设置过期时间是一种常见的做法。这不仅有助于释放不再需要的数据占用的内存空间，还可以防止内存泄漏，保证系统的稳定性和响应速度。

Redis设置的生存时间（TTL，time-to-live）是针对key的。当key的生存时间到达预定值时，这个key将被视为过期。但是，过期并不意味着它会立即从数据库中被删除。

```
# 常用的四种设置key过期时间的命令

EXPIRE <key> <ttl> #表示将键 key 的生存时间设置为 ttl 秒。
 
PEXPIRE <key> <ttl> #表示将键 key 的生存时间设置为 ttl 毫秒。
 
EXPIREAT <key> <timestamp> #表示将键 key 的生存时间设置为 timestamp 所指定的秒数时间戳。
 
PEXPIREAT <key> <timestamp> #表示将键 key 的生存时间设置为 timestamp 所指定的毫秒数时间戳。
```

Redis主要通过两种策略来删除过期的key，即“惰性删除”与“定期删除”。这两种策略相辅相成，旨在平衡内存使用和性能开销。

*   惰性删除：当客户端请求一个key时，Redis会检查该key是否已过期。如果已经过期，Redis就在这个时间点删除该key，然后返回一个错误。这个策略的优点是简单且资源开销小，但缺点是如果过期的key很长时间不被访问，它们将占用内存。

*   定期删除：为了解决惰性删除的缺点，Redis会定期随机测试一批key，检查并删除其中过期的key。这个策略可以更积极地释放内存，但是，频繁地进行定期删除操作可能会对系统性能产生影响。


### 内存淘汰策略

虽然说给key设置过期时间可以节省一部分内存空间，但是当数据量大时，内存使用量很快就会达到配置的上限，新写入的数据将无法存储，这就需要我们预先设定内存淘汰策略，以决定哪些数据应该被淘汰，从而为新数据腾出空间。

Redis提供了多种内存淘汰策略，每种策略都有其特定的使用场景和规则。以下是一些常用的内存淘汰策略：

*   noevition（默认）：此策略不会对缓存的数据进行淘汰，当内存不够了就会返回报错，因此如果真实数据集大于缓存容量，请改用其他策略。

*   volatile-lru：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰。

*   allkeys-lru：从所有数据集中挑选最近最少使用的数据淘汰。

*   volatile-ttl：从已设置过期时间的数据集中挑选将要过期的数据淘汰。

*   volatile-random：从已设置过期时间的数据集中随机挑选数据淘汰。

*   allkeys-random：从所有数据集中随机挑选数据淘汰。

*   volatile-lfu：从已设置过期时间的数据集中挑选使用频率最低的数据淘汰。


从开发的角度出发，选择合适的内存淘汰策略需要考虑业务特点和数据特性。例如，对于一个主要存储用户会话的系统，可能会选择volatile-lru策略，因为会话通常具有时效性，且最近不活跃的会话可以被优先淘汰。

而对于需要保证数据尽可能被缓存的场景，如热点数据缓存，可能会考虑使用allkeys-lru策略，以确保最近最少使用的数据被替换，从而提高缓存命中率。

可通过下面的命令修改淘汰策略。

```
config set maxmemory-policy allkeys-lru
```

### 淘汰策略触发机制

Redis的内存淘汰策略通常会在以下两种情况下触发执行：

*   写命令时：当Redis尝试写入数据时，如果检测到内存使用已经达到了配置的maxmemory限制，Redis就会根据当前设置的内存淘汰策略（例如volatile-lru, allkeys-lru, volatile-random, allkeys-random, volatile-ttl, noeviction等）进行内存清理。在写入新数据前，它会淘汰一些旧数据来释放内存空间，除非配置的是noeviction策略，那么它会拒绝写入并返回错误。

*   定期删除任务：Redis的后台任务会周期性地检查内存使用情况，并根据配置的淘汰策略清除过期或不常用的数据。这是按照一定的时间间隔进行的，以防止内存使用长时间超出限制。这种定期任务结合了惰性删除和主动清理策略，以优化内存使用效率。


## 结语

Redis作为一个强大的工具，在处理过期key时提供了灵活且高效的策略。深入理解这些机制，并通过合理的策略使用，可以确保应用程序在高效使用内存的同时，也能保持良好的响应速度。