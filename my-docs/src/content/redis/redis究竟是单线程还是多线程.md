# redis究竟是单线程还是多线程

Redis作为一个高性能的键值数据库，已经成为了众多开发者青睐的内存数据库解决方案。网上经常看到有人说redis是单线程的，那事实真的是这样吗？

## 单线程数据操作

首先，我们需要理清一个基本概念：所谓的"线程"，是操作系统能够进行运算调度的最小单位。一个线程代表在程序中一个单一的顺序控制流程，多线程则可以让多个运算任务在同一时间段内交替进行，以提高效率。

Redis是以单线程模式著称的，在早期版本中，它的数据操作是完全基于单线程的。但这并不意味着Redis服务器上只存在一个线程，而是说数据的读写、查询等关键操作是由一个主线程负责的。这一设计之所以有效，关键在于Redis是基于内存的数据库，避免了磁盘I/O的瓶颈，通过非阻塞I/O和事件驱动模型，使得单线程能够高效处理大量的并发连接和数据请求。

然而，随着Redis的不断发展和对性能要求的日益提高，单线程模型在某些场景下表现出了性能瓶颈。因此，从Redis 4.0版本开始引入了多线程的概念，用于处理某些特定的任务，如I/O处理、持久化操作等。用多线程来辅助主线程，以提高整体性能，是Redis应对高并发场景和性能要求的一个重要策略。

不过，这并不意味着Redis已完全转向多线程模型。在数据的读写操作中，Redis仍然使用单一主线程来保证数据的一致性和安全性。这种"单线程辅以多线程"的模型，结合了两者的优势：主线程保证简洁高效的数据操作，而多线程则用于处理那些不直接涉及数据一致性的任务，提升了响应速度和处理能力。

也就是说，Redis的主线程仍然承担着大部分的数据操作任务，保持了其单线性的特点。而通过辅助的多线程机制，Redis在不牺牲单线程操作的简洁和安全性的基础上，进一步提升了性能。可以说Redis是一个结合了单线程和多线程优势的混合型内存数据库。

## I/O多路复用

前面提到了I/O处理使用的是多线程，其实不太准确。redis与磁盘的I/O操作，比如RDB和AOF的持久化，都需要从主线程fork出一个子线程来进行，这可以看做是多线程，而网络通信采用的则是I/O多路复用。

首先来看一下下图中的五大I/O模型，然后思考一个问题，I/O多路复用是算单线程还是算多线程？

<table>
    <tr>
        <th></th>
        <th>阻塞</th>
        <th>非阻塞</th>
    </tr>
    <tr>
        <td rowspan="2" style="font-weight: bold">同步</td>
        <td>阻塞I/O模型</td>
        <td>非阻塞I/O模型</td>
    </tr>
    <tr>
        <td>I/O复用模型</td>
        <td>信号驱动的I/O模型</td>
    </tr>
    <tr>
        <td style="font-weight: bold">异步</td>
        <td></td>
        <td>异步I/O模型</td>
    </tr>
</table>

IO多路复用顾名思义指的是单个线程能够监视多个文件描述符（FD），一旦某个FD就绪（例如，数据到来等待读取），相应的操作就可以进行，无需等待其他FD。在Linux中，实现这种机制的API主要有select, poll, 和epoll。这些调用将FD集中起来，由内核一起监视，当FD状态改变时，它们将通知用户进程。

Redis就是采用的epoll机制来处理网络IO操作，让内核监听socket套接字。此时，Redis线程不会阻塞在某一个特定的监听或已连接套接字上，也就是说，不会阻塞在某一个特定的客户端请求处理上。epoll一旦监测到FD上有请求到达时，就会把触发的事件放进一个事件队列中，Redis单线程对该事件队列不断进行处理。正因为此，Redis可以同时和多个客户端连接并处理请求，从而提升并发量。


在Redis 6.0及以后的版本，还引入了多线程来处理网络IO，但这个多线程处理只局限于命令的读取和响应客户端，执行命令仍然是在单线程中进行。这样的设计旨在保持Redis操作的原子性和顺序执行的特性，同时又可以利用多线程来提高网络IO操作的效率。

[阅读原文](https://mp.weixin.qq.com/s?__biz=Mzk0NjQwNzI1MA==&mid=2247484624&idx=1&sn=372658647b0bc14849201d60018600f0&chksm=c307d6edf4705ffb064323a4663c6c25405b52e90c0e36bdbde1acb4276b74d4a0cc5d629b65&token=1234754994&lang=zh_CN#rd)